<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Matchering API - Ownaudio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="docs.css">
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="../index.html" class="logo">OwnaudioSharp</a>
            <ul class="nav-links">
                <li><a href="quickstart.html">Quick Start</a></li>
                <li><a href="api-core.html">Core API</a></li>
                <li><a href="api-net.html">NET API</a></li>
                <li><a href="examples.html">Examples</a></li>
                <li><a href="matchering.html" class="active">Matchering</a></li>
                <li><a href="chorddetect.html">Chord Detection</a></li>
                <!--<li><a href="https://github.com/ModernMube/OwnAudioSharp" target="_blank">GitHub</a></li>-->
            </ul>
        </div>
    </nav>

    <div class="main">
        <aside class="sidebar">
            <h3>Audio Matchering</h3>
            <ul class="sidebar-nav">
                <li><a href="#overview" class="active">Overview</a></li>
                <li><a href="#analyzer">AudioAnalyzer</a></li>
                <li><a href="#data-classes">Data Classes</a></li>
                <li><a href="#analysis-methods">Analysis Methods</a></li>
                <li><a href="#eq-processing">EQ Processing</a></li>
                <li><a href="#presets">Playback Presets</a></li>
                <li><a href="#segmented">Segmented Analysis</a></li>
                <li><a href="#examples">Usage Examples</a></li>
            </ul>
        </aside>

        <main class="content">
            <h1><span class="badge badge-net">NET</span> Audio Matchering API</h1>
            <p>
                Advanced audio spectrum analysis and EQ matching functionality for professional audio mastering.
                Implements FFT-based frequency analysis, intelligent EQ adjustment algorithms, and psychoacoustic optimization.
            </p>

            <div class="alert alert-info">
                <strong>Professional Audio Processing</strong>
                The Matchering API provides sophisticated tools for matching audio characteristics between source and target files,
                with support for segmented analysis, dynamic Q-factor optimization, and playback system presets.
            </div>

            <h2 id="overview">Overview</h2>
            <p>
                The Audio Matchering system enables professional-grade audio mastering by analyzing and matching spectral characteristics:
            </p>
            <ul>
                <li><strong>Segmented Analysis:</strong> Divides audio into overlapping segments for robust analysis</li>
                <li><strong>30-Band ISO EQ:</strong> Professional frequency bands from 20Hz to 16kHz</li>
                <li><strong>Dynamic Q Optimization:</strong> Automatic Q-factor calculation for musical results</li>
                <li><strong>Playback Presets:</strong> Pre-configured settings for 10 different playback systems</li>
                <li><strong>Psychoacoustic Processing:</strong> Intelligent scaling and spectral balance control</li>
                <li><strong>Outlier Detection:</strong> Statistical filtering of non-representative audio segments</li>
            </ul>

            <h3>Key Features</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>Spectral Analysis</h4>
                    <p>FFT-based frequency analysis with Flat-Top windowing for accurate amplitude measurements across 30 ISO-standard bands.</p>
                </div>
                <div class="feature-card">
                    <h4>Intelligent EQ Matching</h4>
                    <p>Automatically calculates and applies EQ adjustments to match source audio to target characteristics with musical results.</p>
                </div>
                <div class="feature-card">
                    <h4>Segmented Approach</h4>
                    <p>Analyzes audio in overlapping segments with weighted averaging and outlier filtering for robust analysis.</p>
                </div>
                <div class="feature-card">
                    <h4>System Presets</h4>
                    <p>Pre-configured frequency response curves for concert PA, club systems, hi-fi speakers, headphones, and more.</p>
                </div>
            </div>

            <h2 id="analyzer">AudioAnalyzer Class</h2>
            <p>
                The <code>AudioAnalyzer</code> partial class provides the core functionality for audio analysis and EQ matching.
            </p>

            <div class="code-block">
                <div class="code-header">AudioAnalyzer Namespace</div>
                <pre><code class="language-csharp">using OwnaudioNET.Features.Matchering;

// Create analyzer instance
var analyzer = new AudioAnalyzer();

// Analyze audio file
AudioSpectrum spectrum = analyzer.AnalyzeAudioFile("input.wav");

// Perform EQ matching
analyzer.ProcessEQMatching(
    sourceFile: "source.wav",
    targetFile: "target.wav", 
    outputFile: "matched.wav"
);</code></pre>
            </div>

            <h3>Public API Methods</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Return</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>AnalyzeAudioFile(string)</code></td>
                        <td>AudioSpectrum</td>
                        <td>Performs enhanced segmented audio analysis with weighted averaging</td>
                    </tr>
                    <tr>
                        <td><code>ProcessEQMatching(string, string, string)</code></td>
                        <td>void</td>
                        <td>Analyzes both files and applies optimal EQ matching to source</td>
                    </tr>
                    <tr>
                        <td><code>ProcessWithEnhancedPreset(...)</code></td>
                        <td>void</td>
                        <td>Applies playback system preset with base sample reference</td>
                    </tr>
                    <tr>
                        <td><code>BatchProcessWithEnhancedPreset(...)</code></td>
                        <td>void</td>
                        <td>Batch processes multiple files with the same preset</td>
                    </tr>
                    <tr>
                        <td><code>GetAvailablePresets()</code></td>
                        <td>Dictionary</td>
                        <td>Returns all available playback system presets</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="data-classes">Data Classes</h2>

            <h3>AudioSpectrum</h3>
            <p>Contains comprehensive audio spectrum analysis results including frequency bands, dynamics, and loudness.</p>

            <div class="code-block">
                <div class="code-header">AudioSpectrum Class</div>
                <pre><code class="language-csharp">public class AudioSpectrum
{
    // Frequency band energy levels (30 ISO bands)
    public float[] FrequencyBands { get; set; } = new float[30];
    
    // RMS level of the audio
    public float RMSLevel { get; set; }
    
    // Peak level of the audio
    public float PeakLevel { get; set; }
    
    // Dynamic range in dB
    public float DynamicRange { get; set; }
    
    // Perceived loudness in LUFS
    public float Loudness { get; set; }
}</code></pre>
            </div>

            <h3>DynamicsInfo</h3>
            <p>Contains audio dynamics analysis information for compression and level management.</p>

            <div class="code-block">
                <div class="code-header">DynamicsInfo Class</div>
                <pre><code class="language-csharp">public class DynamicsInfo
{
    public float RMS { get; set; }           // Root Mean Square level
    public float Peak { get; set; }          // Peak level
    public float DynamicRange { get; set; }  // Dynamic range in dB
    public float Loudness { get; set; }      // Loudness in LUFS
}</code></pre>
            </div>

            <h3>CompressionSettings</h3>
            <p>Defines compression parameters for audio dynamics processing.</p>

            <div class="code-block">
                <div class="code-header">CompressionSettings Class</div>
                <pre><code class="language-csharp">public class CompressionSettings
{
    public float Threshold { get; set; }    // Compression threshold in dB
    public float Ratio { get; set; }        // Compression ratio
    public float AttackTime { get; set; }   // Attack time in milliseconds
    public float ReleaseTime { get; set; }  // Release time in milliseconds
    public float MakeupGain { get; set; }   // Makeup gain in dB
}</code></pre>
            </div>

            <h3>DynamicAmpSettings</h3>
            <p>Configuration for dynamic amplification processing.</p>

            <div class="code-block">
                <div class="code-header">DynamicAmpSettings Class</div>
                <pre><code class="language-csharp">public class DynamicAmpSettings
{
    public float TargetLevel { get; set; }  // Target level in dB
    public float AttackTime { get; set; }   // Attack time in seconds
    public float ReleaseTime { get; set; }  // Release time in seconds
    public float MaxGain { get; set; }      // Maximum gain in dB
}</code></pre>
            </div>

            <h2 id="analysis-methods">Analysis Methods</h2>

            <h3>Spectrum Analysis</h3>
            <p>
                The analysis engine uses FFT with Flat-Top windowing for superior amplitude accuracy.
                Audio is analyzed across 30 ISO-standard frequency bands from 20Hz to 16kHz.
            </p>

            <div class="code-block">
                <div class="code-header">ISO Frequency Bands</div>
                <pre><code class="language-csharp">// Standard ISO frequency bands in Hz
private readonly float[] FrequencyBands = {
    20f, 25f, 31.5f, 40f, 50f, 63f, 80f, 100f, 125f, 160f,      // Sub-bass to bass
    200f, 250f, 315f, 400f, 500f, 630f, 800f, 1000f, 1250f,     // Low-mid
    1600f, 2000f, 2500f, 3150f, 4000f, 5000f,                   // Mid to presence
    6300f, 8000f, 10000f, 12500f, 16000f                        // Brilliance to air
};</code></pre>
            </div>

            <h3>Dynamic Analysis</h3>
            <p>Calculates absolute dynamic characteristics including RMS, peak levels, and LUFS loudness measurements.</p>

            <div class="code-block">
                <div class="code-header">Dynamic Analysis Example</div>
                <pre><code class="language-csharp">// Analyze dynamics
DynamicsInfo dynamics = AnalyzeAbsoluteDynamics(audioData);

Console.WriteLine($"RMS: {dynamics.RMS:F6}");
Console.WriteLine($"Peak: {dynamics.Peak:F6}");
Console.WriteLine($"Loudness: {dynamics.Loudness:F1} dBFS");
Console.WriteLine($"Dynamic Range: {dynamics.DynamicRange:F1} dB");</code></pre>
            </div>

            <h2 id="eq-processing">EQ Processing & Q-Factor Optimization</h2>

            <h3>Intelligent EQ Adjustments</h3>
            <p>
                The system calculates EQ adjustments using psychoacoustic principles and intelligent scaling
                to maintain spectral balance and musicality.
            </p>

            <div class="code-block">
                <div class="code-header">EQ Adjustment Process</div>
                <pre><code class="language-csharp">// Calculate raw spectrum differences
float[] rawAdjustments = new float[30];
for (int i = 0; i < 30; i++)
{
    float sourceLevel = 20 * Math.Log10(source.FrequencyBands[i]);
    float targetLevel = 20 * Math.Log10(target.FrequencyBands[i]);
    rawAdjustments[i] = targetLevel - sourceLevel;
}

// Apply intelligent scaling for musical results
float[] adjustments = ApplyIntelligentScaling(rawAdjustments);</code></pre>
            </div>

            <h3>Dynamic Q-Factor Calculation</h3>
            <p>
                Automatically calculates optimal Q factors for each frequency band based on multiple analysis techniques:
            </p>
            <ul>
                <li><strong>Psychoacoustic base Q:</strong> Frequency-dependent Q values based on hearing research</li>
                <li><strong>Gain-based adjustment:</strong> Larger corrections use narrower Q for surgical precision</li>
                <li><strong>Neighbor correlation:</strong> Similar adjustments in adjacent bands use wider Q</li>
                <li><strong>Spectral density:</strong> Sharp spectral features use narrower Q values</li>
            </ul>

            <div class="code-block">
                <div class="code-header">Q-Factor Optimization</div>
                <pre><code class="language-csharp">// Calculate optimal Q factors
float[] qFactors = CalculateOptimalQFactors(
    eqAdjustments,
    sourceSpectrum,
    targetSpectrum
);

// Apply EQ with optimized Q factors
var eq = new Equalizer30BandEffect(sampleRate);
for (int i = 0; i < FrequencyBands.Length; i++)
{
    eq.SetBandGain(i, FrequencyBands[i], qFactors[i], eqAdjustments[i]);
}</code></pre>
            </div>

            <h3>Spectral Balance Control</h3>
            <p>
                Prevents excessive frequency range dominance with automatic balance correction:
            </p>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Frequency Range</th>
                        <th>Control Method</th>
                        <th>Purpose</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>2.5-5kHz (Vocal Presence)</td>
                        <td>Intelligent limiting</td>
                        <td>Prevents harsh or fatiguing sound</td>
                    </tr>
                    <tr>
                        <td>20-125Hz (Low End)</td>
                        <td>Dominance reduction</td>
                        <td>Maintains clarity and definition</td>
                    </tr>
                    <tr>
                        <td>All Ranges</td>
                        <td>Proportional scaling</td>
                        <td>Overall spectral coherence</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="presets">Playback System Presets</h2>

            <h3>Available Presets</h3>
            <p>
                Ten pre-configured presets optimized for different playback systems, each with custom
                frequency response curves, dynamics settings, and loudness targets.
            </p>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Preset</th>
                        <th>Description</th>
                        <th>Target Loudness</th>
                        <th>Dynamic Range</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>ConcertPA</code></td>
                        <td>Large venue sound reinforcement</td>
                        <td>-16 LUFS</td>
                        <td>18 dB</td>
                    </tr>
                    <tr>
                        <td><code>ClubPA</code></td>
                        <td>Dance music with enhanced bass</td>
                        <td>-11 LUFS</td>
                        <td>8 dB</td>
                    </tr>
                    <tr>
                        <td><code>HiFiSpeakers</code></td>
                        <td>Neutral response for critical listening</td>
                        <td>-18 LUFS</td>
                        <td>20 dB</td>
                    </tr>
                    <tr>
                        <td><code>StudioMonitors</code></td>
                        <td>Professional mixing reference standard</td>
                        <td>-20 LUFS</td>
                        <td>22 dB</td>
                    </tr>
                    <tr>
                        <td><code>Headphones</code></td>
                        <td>Over-ear headphone compensation</td>
                        <td>-16 LUFS</td>
                        <td>16 dB</td>
                    </tr>
                    <tr>
                        <td><code>Earbuds</code></td>
                        <td>In-ear monitors with bass boost</td>
                        <td>-14 LUFS</td>
                        <td>12 dB</td>
                    </tr>
                    <tr>
                        <td><code>CarStereo</code></td>
                        <td>Road noise and cabin compensation</td>
                        <td>-12 LUFS</td>
                        <td>10 dB</td>
                    </tr>
                    <tr>
                        <td><code>Television</code></td>
                        <td>Dialogue clarity focused</td>
                        <td>-15 LUFS</td>
                        <td>12 dB</td>
                    </tr>
                    <tr>
                        <td><code>RadioBroadcast</code></td>
                        <td>FM/AM transmission standards</td>
                        <td>-9 LUFS</td>
                        <td>6 dB</td>
                    </tr>
                    <tr>
                        <td><code>Smartphone</code></td>
                        <td>Small speaker midrange focus</td>
                        <td>-10 LUFS</td>
                        <td>8 dB</td>
                    </tr>
                </tbody>
            </table>

            <h3>PlaybackPreset Class</h3>
            <div class="code-block">
                <div class="code-header">PlaybackPreset Structure</div>
                <pre><code class="language-csharp">public class PlaybackPreset
{
    public string Name { get; set; }                      // Preset name
    public string Description { get; set; }               // Detailed description
    public float[] FrequencyResponse { get; set; }        // 30-band EQ curve in dB
    public float TargetLoudness { get; set; }            // Target LUFS
    public float DynamicRange { get; set; }              // Recommended dB range
    public CompressionSettings Compression { get; set; }  // Compressor settings
    public DynamicAmpSettings DynamicAmp { get; set; }   // Dynamic amp settings
}</code></pre>
            </div>

            <h3>Using Presets</h3>
            <div class="code-block">
                <div class="code-header">Preset Processing Example</div>
                <pre><code class="language-csharp">var analyzer = new AudioAnalyzer();

// Process with specific preset
analyzer.ProcessWithEnhancedPreset(
    sourceFile: "input.wav",
    outputFile: "output.wav",
    system: PlaybackSystem.Headphones,
    eqOnlyMode: true  // Apply only EQ, no dynamics
);

// Batch process multiple files
analyzer.BatchProcessWithEnhancedPreset(
    sourceFiles: new[] { "song1.wav", "song2.wav", "song3.wav" },
    baseSampleFile: "reference.flac",
    outputDirectory: @"C:\Output",
    system: PlaybackSystem.ClubPA,
    fileNameSuffix: "_club"
);

// Get all available presets
var presets = AudioAnalyzer.GetAvailablePresets();
foreach (var preset in presets)
{
    Console.WriteLine($"{preset.Key}: {preset.Value.Name}");
}</code></pre>
            </div>

            <h2 id="segmented">Segmented Analysis Configuration</h2>

            <h3>SegmentedAnalysisConfig</h3>
            <p>
                Configures the segmented analysis approach for more accurate and robust spectrum analysis.
                Audio is divided into overlapping segments, analyzed individually, and combined with weighted averaging.
            </p>

            <div class="code-block">
                <div class="code-header">SegmentedAnalysisConfig Class</div>
                <pre><code class="language-csharp">public class SegmentedAnalysisConfig
{
    // Segment length in seconds (default: 10.0)
    public float SegmentLengthSeconds { get; set; } = 10.0f;
    
    // Overlap ratio between segments (default: 0.2 = 20%)
    public float OverlapRatio { get; set; } = 0.2f;
    
    // Outlier detection threshold in standard deviations (default: 2.5)
    public float OutlierThreshold { get; set; } = 2.5f;
    
    // Use weighted averaging for final spectrum (default: true)
    public bool UseWeightedAveraging { get; set; } = true;
    
    // Minimum energy threshold in dBFS for segment inclusion (default: -60.0)
    public float MinSegmentEnergyThreshold { get; set; } = -60.0f;
}</code></pre>
            </div>

            <h3>Segmented Analysis Process</h3>
            <ol>
                <li><strong>Segment Creation:</strong> Audio divided into overlapping segments (default 10s with 20% overlap)</li>
                <li><strong>Individual Analysis:</strong> Each segment analyzed for frequency spectrum and dynamics</li>
                <li><strong>Energy Filtering:</strong> Segments below energy threshold are excluded</li>
                <li><strong>Outlier Detection:</strong> Statistical analysis identifies and removes non-representative segments</li>
                <li><strong>Weighted Averaging:</strong> Remaining segments combined with energy-based weighting</li>
            </ol>

            <h3>AudioSegment & SegmentAnalysis</h3>
            <div class="code-block">
                <div class="code-header">Segment Data Classes</div>
                <pre><code class="language-csharp">// Audio segment with metadata
public class AudioSegment
{
    public float[] Data { get; set; }        // Audio data
    public float StartTime { get; set; }     // Start time in seconds
    public float Duration { get; set; }      // Duration in seconds
    public float EnergyLevel { get; set; }   // Energy level in dBFS
    public int SampleRate { get; set; }      // Sample rate in Hz
}

// Segment analysis results
public class SegmentAnalysis
{
    public int SegmentIndex { get; set; }             // Segment index
    public float StartTime { get; set; }              // Start time
    public float Duration { get; set; }               // Duration
    public float EnergyLevel { get; set; }            // Energy in dBFS
    public float[] FrequencySpectrum { get; set; }    // Frequency spectrum
    public DynamicsInfo Dynamics { get; set; }        // Dynamics info
    public float Weight { get; set; }                 // Averaging weight
    public float OutlierScore { get; set; }           // Outlier score
}</code></pre>
            </div>

            <h2 id="examples">Usage Examples</h2>

            <h3>Basic EQ Matching</h3>
            <div class="code-block">
                <div class="code-header">Simple EQ Matching</div>
                <pre><code class="language-csharp">using OwnaudioNET.Features.Matchering;

var analyzer = new AudioAnalyzer();

// Match source audio to target characteristics
analyzer.ProcessEQMatching(
    sourceFile: @"C:\Audio\my_track.wav",
    targetFile: @"C:\Audio\reference_track.wav",
    outputFile: @"C:\Audio\my_track_matched.wav"
);

// Console output shows:
// - Segment analysis progress
// - Calculated EQ adjustments
// - Safety features active
// - Final processing status</code></pre>
            </div>

            <h3>Preset-Based Processing</h3>
            <div class="code-block">
                <div class="code-header">Using Playback Presets</div>
                <pre><code class="language-csharp">var analyzer = new AudioAnalyzer();

// Optimize for headphone playback
analyzer.ProcessWithEnhancedPreset(
    sourceFile: "original.wav",
    outputFile: "headphone_optimized.wav",
    system: PlaybackSystem.Headphones,
    tempDirectory: @"C:\Temp",
    eqOnlyMode: true
);

// Optimize for car stereo
analyzer.ProcessWithEnhancedPreset(
    sourceFile: "original.wav",
    outputFile: "car_optimized.wav",
    system: PlaybackSystem.CarStereo,
    eqOnlyMode: false  // Include dynamics processing
);</code></pre>
            </div>

            <h3>Advanced Analysis</h3>
            <div class="code-block">
                <div class="code-header">Detailed Spectrum Analysis</div>
                <pre><code class="language-csharp">var analyzer = new AudioAnalyzer();

// Analyze audio file
AudioSpectrum spectrum = analyzer.AnalyzeAudioFile("audio.wav");

// Access analysis results
Console.WriteLine($"RMS Level: {spectrum.RMSLevel:F3}");
Console.WriteLine($"Peak Level: {spectrum.PeakLevel:F3}");
Console.WriteLine($"Dynamic Range: {spectrum.DynamicRange:F1} dB");
Console.WriteLine($"Loudness: {spectrum.Loudness:F1} LUFS");

// Examine frequency bands
string[] bandNames = { 
    "20Hz", "25Hz", "31Hz", "40Hz", "50Hz", /* ... */ "16kHz" 
};

for (int i = 0; i < spectrum.FrequencyBands.Length; i++)
{
    float energyDB = 20 * (float)Math.Log10(spectrum.FrequencyBands[i]);
    Console.WriteLine($"{bandNames[i]}: {energyDB:F1} dB");
}</code></pre>
            </div>

            <h3>Batch Processing</h3>
            <div class="code-block">
                <div class="code-header">Batch Preset Processing</div>
                <pre><code class="language-csharp">var analyzer = new AudioAnalyzer();

// Process multiple tracks with club preset
string[] tracks = Directory.GetFiles(@"C:\Album", "*.wav");

analyzer.BatchProcessWithEnhancedPreset(
    sourceFiles: tracks,
    baseSampleFile: "club_reference.flac",
    outputDirectory: @"C:\Album\Club",
    system: PlaybackSystem.ClubPA,
    fileNameSuffix: "_club"
);

// Output files will be named:
// track01_club.wav
// track02_club.wav
// etc.</code></pre>
            </div>

            <div class="alert alert-warning">
                <strong>Performance Note</strong>
                Audio analysis is CPU-intensive. Processing time depends on file length, sample rate, 
                and number of segments. Typical processing time is 2-5x real-time on modern CPUs.
            </div>

            <div class="alert alert-success">
                <strong>Safety Features</strong>
                The Matchering API includes multiple safety mechanisms:
                <ul style="margin-top: 0.5rem;">
                    <li>Frequency-specific boost limits to prevent distortion</li>
                    <li>Dynamic headroom calculation for clean processing</li>
                    <li>Psychoacoustic weighting for musical results</li>
                    <li>EQ curve smoothing to prevent harsh corrections</li>
                    <li>Real-time clipping detection and soft limiting</li>
                    <li>Automatic level management to prevent overload</li>
                </ul>
            </div>

            <div style="margin-top: 4rem; padding: 2rem; background: var(--surface); border-radius: 8px;">
                <h3>Related Documentation</h3>
                <ul style="list-style: none; padding: 0;">
                    <li style="margin-bottom: 0.5rem;">
                        <a href="quickstart.html" style="color: var(--primary-color);">üìñ Quick Start Guide</a>
                    </li>
                    <li style="margin-bottom: 0.5rem;">
                        <a href="api-core.html" style="color: var(--core-color);">‚öôÔ∏è Core API Reference</a>
                    </li>
                    <li style="margin-bottom: 0.5rem;">
                        <a href="api-net.html" style="color: var(--net-color);">üéõÔ∏è NET API Reference</a>
                    </li>
                    <li style="margin-bottom: 0.5rem;">
                        <a href="examples.html" style="color: var(--primary-color);">üí° Code Examples</a>
                    </li>
                    <!--<li style="margin-bottom: 0.5rem;">
                        <a href="https://github.com/ModernMube/OwnAudioSharp" target="_blank" style="color: var(--primary-color);">üîó GitHub Repository</a>
                    </li>-->
                </ul>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Active sidebar navigation
        const sections = document.querySelectorAll('h2[id], h3[id]');
        const navLinks = document.querySelectorAll('.sidebar-nav a');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.pageYOffset >= sectionTop - 150) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>