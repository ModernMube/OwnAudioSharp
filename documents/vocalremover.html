<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vocal Remover API - Ownaudio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="docs.css">
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="../index.html" class="logo">OwnaudioSharp</a>
            <ul class="nav-links">
                <li><a href="quickstart.html">Quick Start</a></li>
                <li><a href="api-core.html">Core API</a></li>
                <li><a href="api-net.html">NET API</a></li>
                <li><a href="examples.html">Examples</a></li>
                <li><a href="matchering.html">Matchering</a></li>
                <li><a href="vocalremover.html" class="active">Vocal Remover</a></li>
                <li><a href="chorddetect.html">Chord Detection</a></li>
                <li><a href="https://github.com/ModernMube/OwnAudioSharp" target="_blank">GitHub</a></li>
            </ul>
        </div>
    </nav>

    <div class="main">
        <aside class="sidebar">
            <h3>Vocal Remover</h3>
            <ul class="sidebar-nav">
                <li><a href="#overview" class="active">Overview</a></li>
                <li><a href="#service">AudioSeparationService</a></li>
                <li><a href="#data-classes">Data Classes</a></li>
                <li><a href="#models">Separation Models</a></li>
                <li><a href="#configuration">Configuration</a></li>
                <li><a href="#progress">Progress Tracking</a></li>
                <li><a href="#factory">Factory Methods</a></li>
                <li><a href="#examples">Usage Examples</a></li>
            </ul>
        </aside>

        <main class="content">
            <h1><span class="badge badge-net">NET</span> Vocal Remover API</h1>
            <p>
                Advanced AI-powered audio separation technology for splitting music tracks into vocals and instrumental components.
                Utilizes state-of-the-art ONNX neural network models with STFT-based processing and intelligent noise reduction.
            </p>

            <div class="alert alert-info">
                <strong>Professional Audio Separation</strong>
                The Vocal Remover API provides sophisticated AI-based source separation using deep learning models,
                with support for GPU acceleration, chunked processing, and multiple quality presets.
            </div>

            <h2 id="overview">Overview</h2>
            <p>
                The Vocal Remover system enables professional-grade audio source separation by leveraging advanced AI models:
            </p>
            <ul>
                <li><strong>AI-Powered Separation:</strong> Uses ONNX neural network models for accurate vocal/instrumental separation</li>
                <li><strong>Multiple Model Options:</strong> Choose between Default, Best, and Karaoke models for different use cases</li>
                <li><strong>GPU Acceleration:</strong> Automatic CUDA support for faster processing when available</li>
                <li><strong>Chunked Processing:</strong> Handles long audio files with configurable chunk sizes and overlap margins</li>
                <li><strong>Noise Reduction:</strong> Optional advanced denoising for cleaner results</li>
                <li><strong>Progress Tracking:</strong> Real-time progress updates with detailed status information</li>
            </ul>

            <h3>Key Features</h3>
            <div class="feature-grid">
                <div class="feature-card">
                    <h4>AI Model Selection</h4>
                    <p>Three pre-trained models optimized for different scenarios: Default for balanced quality and speed, Best for maximum quality, and Karaoke for preserving background vocals.</p>
                </div>
                <div class="feature-card">
                    <h4>STFT Processing</h4>
                    <p>Short-Time Fourier Transform based processing with configurable FFT size, Hanning window, and frequency/time dimensions for precise spectral analysis.</p>
                </div>
                <div class="feature-card">
                    <h4>Smart Chunking</h4>
                    <p>Intelligent audio segmentation with overlapping margins for seamless processing of files of any length without memory constraints.</p>
                </div>
                <div class="feature-card">
                    <h4>Hardware Acceleration</h4>
                    <p>Automatic detection and utilization of CUDA-enabled GPUs for significantly faster processing, with CPU fallback for compatibility.</p>
                </div>
            </div>

            <h2 id="service">SimpleAudioSeparationService Class</h2>
            <p>
                The <code>SimpleAudioSeparationService</code> class provides the core functionality for audio separation.
            </p>

            <div class="code-block">
                <div class="code-header">AudioSeparationService Namespace</div>
                <pre><code class="language-csharp">using OwnaudioNET.Features.Vocalremover;

// Create service with custom options
var options = new SimpleSeparationOptions
{
    Model = InternalModel.Best,
    OutputDirectory = "output",
    ChunkSizeSeconds = 15,
    DisableNoiseReduction = false
};

var service = new SimpleAudioSeparationService(options);
service.Initialize();

// Separate audio file
SimpleSeparationResult result = service.Separate("input.mp3");

Console.WriteLine($"Vocals: {result.VocalsPath}");
Console.WriteLine($"Instrumental: {result.InstrumentalPath}");
Console.WriteLine($"Processing time: {result.ProcessingTime}");</code></pre>
            </div>

            <h3>Public API Methods</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>Method</th>
                        <th>Return</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>Initialize()</code></td>
                        <td>void</td>
                        <td>Initializes the ONNX model session with GPU or CPU execution provider</td>
                    </tr>
                    <tr>
                        <td><code>Separate(string)</code></td>
                        <td>SimpleSeparationResult</td>
                        <td>Separates audio file into vocals and instrumental tracks</td>
                    </tr>
                    <tr>
                        <td><code>Dispose()</code></td>
                        <td>void</td>
                        <td>Releases all resources including ONNX session</td>
                    </tr>
                </tbody>
            </table>

            <h3>Events</h3>
            <table class="api-table">
                <thead>
                    <tr>
                        <th>Event</th>
                        <th>Type</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>ProgressChanged</code></td>
                        <td>EventHandler&lt;SimpleSeparationProgress&gt;</td>
                        <td>Raised when processing progress updates</td>
                    </tr>
                    <tr>
                        <td><code>ProcessingCompleted</code></td>
                        <td>EventHandler&lt;SimpleSeparationResult&gt;</td>
                        <td>Raised when separation completes successfully</td>
                    </tr>
                </tbody>
            </table>

            <h2 id="data-classes">Data Classes</h2>

            <h3>SimpleSeparationOptions</h3>
            <p>Configuration parameters for the audio separation process.</p>

            <div class="code-block">
                <div class="code-header">SimpleSeparationOptions Class</div>
                <pre><code class="language-csharp">public class SimpleSeparationOptions
{
    // ONNX model file path (optional if using internal models)
    public string? ModelPath { get; set; }

    // Internal model selection (Default, Best, Karaoke)
    public InternalModel Model { get; set; } = InternalModel.Best;

    // Output directory path
    public string OutputDirectory { get; set; } = "separated";

    // Disable noise reduction (enabled by default)
    public bool DisableNoiseReduction { get; set; } = false;

    // Margin size for overlapping chunks (in samples, default: 44100 = 1 second)
    public int Margin { get; set; } = 44100;

    // Chunk size in seconds (0 = process entire file at once)
    public int ChunkSizeSeconds { get; set; } = 15;

    // FFT size for STFT processing
    public int NFft { get; set; } = 6144;

    // Temporal dimension parameter (as power of 2)
    public int DimT { get; set; } = 8;

    // Frequency dimension parameter
    public int DimF { get; set; } = 2048;
}</code></pre>
            </div>

            <h3>SimpleSeparationProgress</h3>
            <p>Progress information for the separation process.</p>

            <div class="code-block">
                <div class="code-header">SimpleSeparationProgress Class</div>
                <pre><code class="language-csharp">public class SimpleSeparationProgress
{
    // Current file being processed
    public string CurrentFile { get; set; }

    // Overall progress percentage (0-100)
    public double OverallProgress { get; set; }

    // Current processing step description
    public string Status { get; set; }

    // Number of chunks processed
    public int ProcessedChunks { get; set; }

    // Total number of chunks
    public int TotalChunks { get; set; }
}</code></pre>
            </div>

            <h3>SimpleSeparationResult</h3>
            <p>Result of the audio separation operation.</p>

            <div class="code-block">
                <div class="code-header">SimpleSeparationResult Class</div>
                <pre><code class="language-csharp">public class SimpleSeparationResult
{
    // Path to the vocals output file
    public string VocalsPath { get; set; }

    // Path to the instrumental output file
    public string InstrumentalPath { get; set; }

    // Processing duration
    public TimeSpan ProcessingTime { get; set; }
}</code></pre>
            </div>

            <h2 id="models">Separation Models</h2>

            <h3>Available Models</h3>
            <p>
                Three built-in models optimized for different use cases, each embedded in the library for seamless usage:
            </p>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Model</th>
                        <th>Quality</th>
                        <th>Speed</th>
                        <th>Best For</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>Default</code></td>
                        <td>Good</td>
                        <td>Fast</td>
                        <td>General purpose separation with balanced quality and processing time. Ideal for quick previews and batch processing.</td>
                    </tr>
                    <tr>
                        <td><code>Best</code></td>
                        <td>Excellent</td>
                        <td>Slower</td>
                        <td>Maximum quality separation for professional applications. Produces the cleanest vocal and instrumental tracks with minimal artifacts.</td>
                    </tr>
                    <tr>
                        <td><code>Karaoke</code></td>
                        <td>Specialized</td>
                        <td>Medium</td>
                        <td>Removes lead vocals while preserving background vocals. Perfect for creating karaoke tracks with choir or backing vocal presence.</td>
                    </tr>
                </tbody>
            </table>

            <h3>Model Selection</h3>
            <div class="code-block">
                <div class="code-header">InternalModel Enum</div>
                <pre><code class="language-csharp">public enum InternalModel
{
    None,      // Use custom model file via ModelPath
    Default,   // Balanced quality and speed
    Best,      // Highest quality, longer processing time
    Karaoke    // Preserve background vocals, remove lead vocal
}

// Usage examples
var options1 = new SimpleSeparationOptions { Model = InternalModel.Default };
var options2 = new SimpleSeparationOptions { Model = InternalModel.Best };
var options3 = new SimpleSeparationOptions { Model = InternalModel.Karaoke };

// Custom model
var options4 = new SimpleSeparationOptions
{
    Model = InternalModel.None,
    ModelPath = @"C:\Models\custom_model.onnx"
};</code></pre>
            </div>

            <h3>Model Characteristics</h3>
            <ul>
                <li><strong>Default Model:</strong> The most balanced option, providing good quality separation with relatively fast processing times. Suitable for most use cases where a reasonable quality-speed tradeoff is acceptable.</li>
                <li><strong>Best Model:</strong> Utilizes a larger and more complex neural network architecture, resulting in superior separation quality with cleaner vocals and instrumental tracks. Processing time is approximately 2-3x longer than the Default model.</li>
                <li><strong>Karaoke Model:</strong> Specifically trained to remove only the lead vocal while preserving backing vocals, harmonies, and vocal effects. This creates a more authentic karaoke experience compared to complete vocal removal.</li>
            </ul>

            <h2 id="configuration">Advanced Configuration</h2>

            <h3>Processing Parameters</h3>
            <p>
                Fine-tune the separation process with advanced STFT and chunking parameters:
            </p>

            <table class="api-table">
                <thead>
                    <tr>
                        <th>Parameter</th>
                        <th>Default</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><code>ChunkSizeSeconds</code></td>
                        <td>15</td>
                        <td>Length of each processing chunk in seconds. Smaller values use less memory but increase processing overhead.</td>
                    </tr>
                    <tr>
                        <td><code>Margin</code></td>
                        <td>44100</td>
                        <td>Overlap margin in samples between chunks. Prevents artifacts at chunk boundaries. Should be at least 0.5 seconds.</td>
                    </tr>
                    <tr>
                        <td><code>NFft</code></td>
                        <td>6144</td>
                        <td>FFT size for spectral analysis. Higher values provide better frequency resolution but increase computation time.</td>
                    </tr>
                    <tr>
                        <td><code>DimF</code></td>
                        <td>2048</td>
                        <td>Frequency dimension for model input. Auto-detected from model metadata if not specified.</td>
                    </tr>
                    <tr>
                        <td><code>DimT</code></td>
                        <td>8</td>
                        <td>Time dimension as power of 2 (2^8 = 256 time frames). Auto-detected from model metadata if not specified.</td>
                    </tr>
                    <tr>
                        <td><code>DisableNoiseReduction</code></td>
                        <td>false</td>
                        <td>When false, applies advanced noise reduction using phase inversion technique for cleaner results.</td>
                    </tr>
                </tbody>
            </table>

            <h3>Hardware Acceleration</h3>
            <p>
                The service automatically detects and utilizes available hardware acceleration:
            </p>

            <div class="code-block">
                <div class="code-header">GPU Acceleration</div>
                <pre><code class="language-csharp">// Automatic GPU detection during initialization
service.Initialize();

// Console output will show:
// "CUDA execution provider enabled." (if GPU available)
// OR
// "Using CPU execution provider." (fallback)

// Processing speed comparison:
// CPU: ~2-5x real-time (depends on CPU cores)
// GPU (CUDA): ~10-30x real-time (depends on GPU model)</code></pre>
            </div>

            <h3>Memory Management</h3>
            <p>
                For large files or systems with limited memory, adjust chunk size and margin:
            </p>

            <div class="code-block">
                <div class="code-header">Memory Optimization</div>
                <pre><code class="language-csharp">// Low memory configuration (suitable for 4GB RAM)
var lowMemOptions = new SimpleSeparationOptions
{
    Model = InternalModel.Default,
    ChunkSizeSeconds = 10,  // Smaller chunks
    Margin = 22050         // 0.5 second margin
};

// High quality configuration (requires 8GB+ RAM)
var highQualityOptions = new SimpleSeparationOptions
{
    Model = InternalModel.Best,
    ChunkSizeSeconds = 30,  // Larger chunks for better quality
    Margin = 88200          // 2 second margin for smoother transitions
};</code></pre>
            </div>

            <h2 id="progress">Progress Tracking</h2>

            <h3>Monitoring Progress</h3>
            <p>
                Track separation progress in real-time using event handlers:
            </p>

            <div class="code-block">
                <div class="code-header">Progress Event Handling</div>
                <pre><code class="language-csharp">var service = new SimpleAudioSeparationService(options);

// Subscribe to progress events
service.ProgressChanged += (sender, progress) =>
{
    Console.WriteLine($"[{progress.OverallProgress:F1}%] {progress.Status}");

    if (progress.TotalChunks > 0)
    {
        Console.WriteLine($"Chunk {progress.ProcessedChunks}/{progress.TotalChunks}");
    }
};

// Subscribe to completion event
service.ProcessingCompleted += (sender, result) =>
{
    Console.WriteLine($"\nSeparation completed in {result.ProcessingTime}");
    Console.WriteLine($"Vocals saved to: {result.VocalsPath}");
    Console.WriteLine($"Instrumental saved to: {result.InstrumentalPath}");
};

service.Initialize();
service.Separate("song.mp3");</code></pre>
            </div>

            <h3>Progress Stages</h3>
            <ol>
                <li><strong>Loading audio file (0%):</strong> Decoding input audio to 44.1kHz stereo format</li>
                <li><strong>Processing audio separation (10%):</strong> Creating and processing audio chunks</li>
                <li><strong>Processing chunks (20-80%):</strong> Running neural network inference on each chunk</li>
                <li><strong>Calculating results (90%):</strong> Reconstructing full-length separated tracks</li>
                <li><strong>Completed (100%):</strong> Saving output files to disk</li>
            </ol>

            <h2 id="factory">Factory Methods</h2>

            <h3>AudioSeparationExtensions</h3>
            <p>
                Convenient factory methods for quick service creation:
            </p>

            <div class="code-block">
                <div class="code-header">Factory Methods</div>
                <pre><code class="language-csharp">using OwnaudioNET.Features.Vocalremover;

// Create service with internal model
var service1 = AudioSeparationExtensions.CreateDefaultService(InternalModel.Best);

// Create service with custom model file
var service2 = AudioSeparationExtensions.CreateDefaultService("path/to/model.onnx");

// Create service with custom output directory
var service3 = AudioSeparationExtensions.CreatetService(
    InternalModel.Karaoke,
    @"C:\Output\Karaoke"
);

// Create service with custom model and output
var service4 = AudioSeparationExtensions.CreatetService(
    "custom_model.onnx",
    @"C:\Output\Custom"
);</code></pre>
            </div>

            <h3>SimpleSeparator Factory</h3>
            <p>
                Simplified factory for quick one-line initialization:
            </p>

            <div class="code-block">
                <div class="code-header">SimpleSeparator Usage</div>
                <pre><code class="language-csharp">// Quick initialization and separation
var (service, _, _) = SimpleSeparator.Separator(
    InternalModel.Default,
    "output_folder"
);

var result = service.Separate("input.wav");
service.Dispose();</code></pre>
            </div>

            <h3>Helper Methods</h3>
            <div class="code-block">
                <div class="code-header">Audio Validation & Estimation</div>
                <pre><code class="language-csharp">// Validate audio file format
bool isValid = AudioSeparationExtensions.IsValidAudioFile("song.mp3");
// Supports: .wav, .mp3, .flac

// Estimate processing time
TimeSpan estimate = AudioSeparationExtensions.EstimateProcessingTime("song.wav");
Console.WriteLine($"Estimated processing time: {estimate}");</code></pre>
            </div>

            <h2 id="examples">Usage Examples</h2>

            <h3>Basic Vocal Removal</h3>
            <div class="code-block">
                <div class="code-header">Simple Vocal Removal</div>
                <pre><code class="language-csharp">using OwnaudioNET.Features.Vocalremover;

// Create service with default settings
var options = new SimpleSeparationOptions
{
    Model = InternalModel.Default,
    OutputDirectory = "separated"
};

using var service = new SimpleAudioSeparationService(options);
service.Initialize();

// Separate audio file
var result = service.Separate(@"C:\Music\song.mp3");

Console.WriteLine($"Vocals: {result.VocalsPath}");
Console.WriteLine($"Instrumental: {result.InstrumentalPath}");
Console.WriteLine($"Time: {result.ProcessingTime.TotalSeconds:F1}s");</code></pre>
            </div>

            <h3>High-Quality Separation with Progress</h3>
            <div class="code-block">
                <div class="code-header">Best Quality with Progress Tracking</div>
                <pre><code class="language-csharp">var options = new SimpleSeparationOptions
{
    Model = InternalModel.Best,
    OutputDirectory = "output_best",
    ChunkSizeSeconds = 20,
    DisableNoiseReduction = false  // Enable noise reduction
};

using var service = new SimpleAudioSeparationService(options);

// Progress tracking
service.ProgressChanged += (s, p) =>
{
    Console.Write($"\r[{p.OverallProgress:F1}%] {p.Status}");
    if (p.TotalChunks > 0)
        Console.Write($" - Chunk {p.ProcessedChunks}/{p.TotalChunks}");
};

service.ProcessingCompleted += (s, r) =>
{
    Console.WriteLine($"\n\nCompleted in {r.ProcessingTime}");
    Console.WriteLine($"Output files:\n  {r.VocalsPath}\n  {r.InstrumentalPath}");
};

service.Initialize();
service.Separate("input_song.flac");</code></pre>
            </div>

            <h3>Karaoke Track Creation</h3>
            <div class="code-block">
                <div class="code-header">Creating Karaoke Tracks</div>
                <pre><code class="language-csharp">// Use Karaoke model to preserve background vocals
var options = new SimpleSeparationOptions
{
    Model = InternalModel.Karaoke,
    OutputDirectory = "karaoke_tracks"
};

using var service = new SimpleAudioSeparationService(options);
service.Initialize();

// Process multiple songs
string[] songs = Directory.GetFiles(@"C:\Music\Album", "*.mp3");

foreach (var song in songs)
{
    Console.WriteLine($"\nProcessing: {Path.GetFileName(song)}");
    var result = service.Separate(song);
    Console.WriteLine($"Karaoke track created: {result.InstrumentalPath}");
}</code></pre>
            </div>

            <h3>Batch Processing with Factory Method</h3>
            <div class="code-block">
                <div class="code-header">Batch Vocal Removal</div>
                <pre><code class="language-csharp">// Create service using factory
var service = AudioSeparationExtensions.CreatetService(
    InternalModel.Default,
    @"C:\Output\Vocals_Removed"
);

service.Initialize();

// Process all WAV files in directory
var files = Directory.GetFiles(@"C:\Music", "*.wav");
int count = 0;

foreach (var file in files)
{
    try
    {
        Console.WriteLine($"\n[{++count}/{files.Length}] {Path.GetFileName(file)}");
        var result = service.Separate(file);
        Console.WriteLine($"‚úì Completed in {result.ProcessingTime.TotalSeconds:F1}s");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"‚úó Error: {ex.Message}");
    }
}

service.Dispose();</code></pre>
            </div>

            <h3>Custom Model Configuration</h3>
            <div class="code-block">
                <div class="code-header">Using Custom ONNX Models</div>
                <pre><code class="language-csharp">// Load custom trained model
var options = new SimpleSeparationOptions
{
    Model = InternalModel.None,
    ModelPath = @"C:\Models\my_custom_separator.onnx",
    OutputDirectory = "custom_output",

    // Adjust STFT parameters if needed for custom model
    NFft = 4096,
    DimF = 1024,
    DimT = 9  // 2^9 = 512 time frames
};

using var service = new SimpleAudioSeparationService(options);
service.Initialize();

// Model parameters are auto-detected from ONNX metadata
var result = service.Separate("test.wav");</code></pre>
            </div>

            <div class="alert alert-warning">
                <strong>Performance Note</strong>
                Audio separation is computationally intensive. Processing time varies significantly based on:
                <ul style="margin-top: 0.5rem;">
                    <li><strong>Model choice:</strong> Best model is 2-3x slower than Default</li>
                    <li><strong>Hardware:</strong> GPU acceleration provides 5-15x speedup over CPU</li>
                    <li><strong>File length:</strong> Processing time scales linearly with audio duration</li>
                    <li><strong>Chunk size:</strong> Larger chunks are more efficient but use more memory</li>
                </ul>
                Typical processing time on modern hardware: 2-10x real-time on CPU, 0.2-1x real-time on GPU.
            </div>

            <div class="alert alert-success">
                <strong>Technical Features</strong>
                The Vocal Remover API includes advanced audio processing techniques:
                <ul style="margin-top: 0.5rem;">
                    <li>STFT with Hanning window for accurate frequency-domain representation</li>
                    <li>Reflection padding to prevent boundary artifacts</li>
                    <li>Hermitian symmetry for proper inverse FFT reconstruction</li>
                    <li>Overlap-add synthesis with automatic windowing compensation</li>
                    <li>Phase inversion noise reduction for cleaner separation results</li>
                    <li>Automatic normalization to prevent clipping in output files</li>
                    <li>44.1kHz stereo processing for optimal quality</li>
                </ul>
            </div>

            <div class="alert alert-info">
                <strong>Supported Audio Formats</strong>
                The Vocal Remover supports common audio formats through the Ownaudio decoder:
                <ul style="margin-top: 0.5rem;">
                    <li>WAV (uncompressed PCM)</li>
                    <li>MP3 (MPEG Audio Layer 3)</li>
                    <li>FLAC (Free Lossless Audio Codec)</li>
                </ul>
                Output files are always saved as 16-bit WAV at 44.1kHz stereo.
            </div>

            <div style="margin-top: 4rem; padding: 2rem; background: var(--surface); border-radius: 8px;">
                <h3>Related Documentation</h3>
                <ul style="list-style: none; padding: 0;">
                    <li style="margin-bottom: 0.5rem;">
                        <a href="quickstart.html" style="color: var(--primary-color);">üìñ Quick Start Guide</a>
                    </li>
                    <li style="margin-bottom: 0.5rem;">
                        <a href="api-core.html" style="color: var(--core-color);">‚öôÔ∏è Core API Reference</a>
                    </li>
                    <li style="margin-bottom: 0.5rem;">
                        <a href="api-net.html" style="color: var(--net-color);">üéõÔ∏è NET API Reference</a>
                    </li>
                    <li style="margin-bottom: 0.5rem;">
                        <a href="matchering.html" style="color: var(--primary-color);">üéöÔ∏è Audio Matchering</a>
                    </li>
                    <li style="margin-bottom: 0.5rem;">
                        <a href="examples.html" style="color: var(--primary-color);">üí° Code Examples</a>
                    </li>
                </ul>
            </div>
        </main>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // Active sidebar navigation
        const sections = document.querySelectorAll('h2[id], h3[id]');
        const navLinks = document.querySelectorAll('.sidebar-nav a');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.pageYOffset >= sectionTop - 150) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });

        // Smooth scrolling
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>
