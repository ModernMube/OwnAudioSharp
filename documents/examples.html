<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-93P1X5V4Z5"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'G-93P1X5V4Z5');
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examples - Ownaudio</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="docs.css">
</head>
<body>
    <nav class="nav">
        <div class="nav-container">
            <a href="../index.html" class="logo">OwnaudioSharp</a>
            <ul class="nav-links">
                <li><a href="quickstart.html">Quick Start</a></li>
                <li><a href="api-core.html">Core API</a></li>
                <li><a href="api-net.html">NET API</a></li>
                <li><a href="examples.html" class="active">Examples</a></li>
                <li><a href="matchering.html">Matchering</a></li>
                <li><a href="chorddetect.html">Chord Detection</a></li>
                <li><a href="https://github.com/ModernMube/OwnAudioSharp" target="_blank">GitHub</a></li>
            </ul>
        </div>
    </nav>

    <div class="main">
        <aside class="sidebar">
            <h3>Example Navigation</h3>
            <ul class="sidebar-nav">
                <li><a href="#overview" class="active">Overview</a></li>
                <li><a href="#step1-init">1. Engine Initialization</a></li>
                <li><a href="#step2-start">2. Starting Engine</a></li>
                <li><a href="#step3-mixer">3. Mixer Setup</a></li>
                <li><a href="#step4-effects">4. Master Effects</a></li>
                <li><a href="#step5-sources">5. Audio Sources</a></li>
                <li><a href="#step6-playback">6. Synchronized Playback</a></li>
                <li><a href="#step7-monitoring">7. Monitoring & Effects</a></li>
                <li><a href="#step8-cleanup">8. Cleanup</a></li>
            </ul>
        </aside>

        <main class="content">
            <h1>Complete AudioMixer Example</h1>
            <p>This comprehensive example demonstrates the usage of OwnaudioNET with multi-track playback, master effects, and synchronized playback control.</p>

            <div class="alert alert-info">
                <strong>Developer Example</strong>
                This code demonstrates the practical usage of the OwnaudioNET API. All classes and methods used in this example are documented in the API reference.
            </div>

            <h2 id="overview">Overview</h2>
            <p>This example program demonstrates the following features:</p>
            <ul>
                <li><strong>Audio Engine initialization</strong> with custom configuration</li>
                <li><strong>AudioMixer creation</strong> with direct engine access</li>
                <li><strong>Master effects chain</strong> (Equalizer, Compressor, Dynamic Amp)</li>
                <li><strong>Multi-track playback</strong> with four separate audio files</li>
                <li><strong>Synchronized playback</strong> with drift correction</li>
                <li><strong>Real-time monitoring</strong> with position and peak levels</li>
                <li><strong>Dynamic effect activation</strong> during playback</li>
            </ul>

            <h2 id="step1-init">Step 1: Audio Engine Initialization</h2>
            <p>The first step is to initialize the audio engine with a custom configuration. We configure the sample rate, channel count, and buffer size for optimal performance.</p>

            <div class="code-block">
                <div class="code-header">Engine Initialization</div>
                <pre><code class="language-csharp">using Ownaudio.Core;
using OwnaudioNET.Core;

AudioConfig config = new AudioConfig()
{
    SampleRate = 48000,
    Channels = 2,
    BufferSize = 512
};

OwnaudioNet.Initialize(config);

Console.WriteLine($"Initialized: {OwnaudioNet.IsInitialized}");
Console.WriteLine($"Version: {OwnaudioNet.Version}");
Console.WriteLine($"Sample Rate: {OwnaudioNet.Engine?.Config.SampleRate} Hz");
Console.WriteLine($"Channels: {OwnaudioNet.Engine?.Config.Channels}");
Console.WriteLine($"Buffer Size: {OwnaudioNet.Engine?.FramesPerBuffer} frames");</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Create an <code>AudioConfig</code> object with 48kHz sample rate, stereo (2 channels), and 512 frames buffer size</li>
                <li>Initialize the OwnaudioNET static instance with this configuration</li>
                <li>The engine automatically detects the platform and uses the appropriate native audio API (WASAPI on Windows, Core Audio on macOS, PulseAudio on Linux)</li>
                <li>Display initialization status and audio configuration parameters</li>
            </ul>

            <h2 id="step2-start">Step 2: Starting the Audio Engine</h2>
            <p>After initialization, we start the audio engine to begin processing audio.</p>

            <div class="code-block">
                <div class="code-header">Starting Engine</div>
                <pre><code class="language-csharp">OwnaudioNet.Start();

Console.WriteLine($"Engine running: {OwnaudioNet.IsRunning}");</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>The <code>Start()</code> method activates the audio engine's real-time processing thread</li>
                <li>The engine begins requesting audio buffers from registered sources</li>
                <li>At this point, the engine is ready to accept audio sources and play them</li>
            </ul>

            <h2 id="step3-mixer">Step 3: Creating the Audio Mixer</h2>
            <p>We create an AudioMixer instance with direct engine access for optimal performance, bypassing additional wrapper layers.</p>

            <div class="code-block">
                <div class="code-header">Mixer Creation</div>
                <pre><code class="language-csharp">using OwnaudioNET.Mixing;

var Engine = OwnaudioNet.Engine!.UnderlyingEngine;

mixer = new AudioMixer(Engine, bufferSizeInFrames: 512);

mixer.MasterVolume = 0.8f;

mixer.SourceError += (sender, e) =>
{
    Console.WriteLine($"Source error: {e.Message}");
};</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Get direct access to the underlying engine (<code>IAudioEngine</code>) for maximum performance</li>
                <li>Create an <code>AudioMixer</code> with 512 frames internal buffer size</li>
                <li>Set master volume to 80% (0.8f) which applies to the final mixed output</li>
                <li>Register an error handler for any source-related errors during playback</li>
                <li>The mixer will handle mixing multiple audio sources into a single output stream</li>
            </ul>

            <h2 id="step4-effects">Step 4: Master Effects Configuration</h2>
            <p>Configure and add master effects that will be applied to the final mixed output. These effects process all sources together.</p>

            <div class="code-block">
                <div class="code-header">Equalizer Setup (30-Band)</div>
                <pre><code class="language-csharp">using OwnaudioNET.Effects;

var _equalizer = new Equalizer30BandEffect();

_equalizer.SetBandGain(band: 0, frequency: 20, q: 0.5f, gainDB: 0.2f);
_equalizer.SetBandGain(band: 1, frequency: 25, q: 0.5f, gainDB: 0.4f);
_equalizer.SetBandGain(band: 2, frequency: 31, q: 0.6f, gainDB: 0.6f);
_equalizer.SetBandGain(band: 3, frequency: 40, q: 0.7f, gainDB: 0.8f);
_equalizer.SetBandGain(band: 4, frequency: 50, q: 0.7f, gainDB: 0.8f);
_equalizer.SetBandGain(band: 5, frequency: 63, q: 0.7f, gainDB: -0.3f);

_equalizer.SetBandGain(band: 6, frequency: 80, q: 0.8f, gainDB: 0.3f);
_equalizer.SetBandGain(band: 7, frequency: 100, q: 0.8f, gainDB: 0.5f);
_equalizer.SetBandGain(band: 8, frequency: 125, q: 0.9f, gainDB: 0.3f);
_equalizer.SetBandGain(band: 9, frequency: 160, q: 0.9f, gainDB: 0.1f);

_equalizer.SetBandGain(band: 10, frequency: 200, q: 1.0f, gainDB: -0.4f);
_equalizer.SetBandGain(band: 11, frequency: 250, q: 1.0f, gainDB: -0.8f);
_equalizer.SetBandGain(band: 12, frequency: 315, q: 1.1f, gainDB: -0.7f);
_equalizer.SetBandGain(band: 13, frequency: 400, q: 1.1f, gainDB: -0.5f);
_equalizer.SetBandGain(band: 14, frequency: 500, q: 1.0f, gainDB: -0.2f);

_equalizer.SetBandGain(band: 15, frequency: 630, q: 1.0f, gainDB: -0.1f);
_equalizer.SetBandGain(band: 16, frequency: 800, q: 1.0f, gainDB: 0.0f);
_equalizer.SetBandGain(band: 17, frequency: 1000, q: 1.0f, gainDB: 0.0f);
_equalizer.SetBandGain(band: 18, frequency: 1250, q: 1.0f, gainDB: 0.0f);
_equalizer.SetBandGain(band: 19, frequency: 1600, q: 1.0f, gainDB: 0.1f);

_equalizer.SetBandGain(band: 20, frequency: 2000, q: 1.0f, gainDB: 0.3f);
_equalizer.SetBandGain(band: 21, frequency: 2500, q: 0.9f, gainDB: 0.5f);
_equalizer.SetBandGain(band: 22, frequency: 3150, q: 0.9f, gainDB: 0.7f);
_equalizer.SetBandGain(band: 23, frequency: 4000, q: 0.8f, gainDB: 0.5f);
_equalizer.SetBandGain(band: 24, frequency: 5000, q: 0.7f, gainDB: 0.3f);

_equalizer.SetBandGain(band: 25, frequency: 6300, q: 0.7f, gainDB: 0.3f);
_equalizer.SetBandGain(band: 26, frequency: 8000, q: 0.6f, gainDB: 0.6f);
_equalizer.SetBandGain(band: 27, frequency: 10000, q: 0.6f, gainDB: 0.8f);
_equalizer.SetBandGain(band: 28, frequency: 12500, q: 0.5f, gainDB: 1.0f);
_equalizer.SetBandGain(band: 29, frequency: 16000, q: 0.5f, gainDB: 1.0f);</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Create a 30-band parametric equalizer with professional frequency bands</li>
                <li><strong>Sub-bass (20-63 Hz):</strong> Enhanced low-end with controlled boost</li>
                <li><strong>Bass (80-160 Hz):</strong> Punch and body for kick drums and bass</li>
                <li><strong>Low-mid (200-500 Hz):</strong> Reduce mud and boxiness</li>
                <li><strong>Mid (630-1600 Hz):</strong> Neutral balance for vocal clarity</li>
                <li><strong>Upper-mid (2000-5000 Hz):</strong> Presence and definition boost</li>
                <li><strong>High (6300-16000 Hz):</strong> Airiness and brilliance</li>
            </ul>

            <div class="code-block">
                <div class="code-header">Compressor and Dynamic Amp</div>
                <pre><code class="language-csharp">var _compressor = new CompressorEffect(CompressorPreset.Vintage);

mixer.AddMasterEffect(_equalizer);
mixer.AddMasterEffect(_compressor);
mixer.AddMasterEffect(new DynamicAmpEffect(DynamicAmpPreset.Live));

_equalizer.Enabled = false;
_compressor.Enabled = false;</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Create a vintage-style compressor for warm, musical compression</li>
                <li>Add all three effects to the master effects chain (processed in order)</li>
                <li>Add a dynamic amplifier with "Live" preset for final output enhancement</li>
                <li>Initially disable equalizer and compressor (they will be enabled at 30 seconds)</li>
                <li>Master effects are applied to the final mixed output from all sources</li>
            </ul>

            <h2 id="step5-sources">Step 5: Creating Audio Sources</h2>
            <p>Create multiple audio sources from WAV files and configure them for synchronized playback.</p>

            <div class="code-block">
                <div class="code-header">File Source Creation</div>
                <pre><code class="language-csharp">using OwnaudioNET.Sources;
using System.Reflection;

string? exePath = Assembly.GetExecutingAssembly().Location;
string? exeDirectory = Path.GetDirectoryName(exePath);

string audioFilePath0 = Path.Combine(exeDirectory, "media", "drums.wav");
string audioFilePath1 = Path.Combine(exeDirectory, "media", "bass.wav");
string audioFilePath2 = Path.Combine(exeDirectory, "media", "other.wav");
string audioFilePath3 = Path.Combine(exeDirectory, "media", "vocals.wav");

int targetSampleRate = OwnaudioNet.Engine!.Config.SampleRate;
int targetChannels = OwnaudioNet.Engine!.Config.Channels;

fileSource0 = new FileSource(audioFilePath0, 8192, targetSampleRate, targetChannels);
fileSource1 = new FileSource(audioFilePath1, 8192, targetSampleRate, targetChannels);
fileSource2 = new FileSource(audioFilePath2, 8192, targetSampleRate, targetChannels);
fileSource3 = new FileSource(audioFilePath3, 8192, targetSampleRate, targetChannels);

fileSource0.Volume = 0.9f;
fileSource1.Volume = 0.85f;
fileSource2.Volume = 0.8f;
fileSource3.Volume = 1.0f;</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Locate the application directory and construct paths to audio files</li>
                <li>Get the engine's target sample rate and channel configuration</li>
                <li>Create four <code>FileSource</code> instances with 8192 sample internal buffer</li>
                <li>Each source automatically resamples and converts to match engine format</li>
                <li>Set individual volume levels for each track (drums, bass, other, vocals)</li>
                <li>The sources are ready but not yet playing</li>
            </ul>

            <h2 id="step6-playback">Step 6: Synchronized Playback Setup</h2>
            <p>Add sources to the mixer and configure synchronized playback with drift correction.</p>

            <div class="code-block">
                <div class="code-header">Mixer Configuration and Sync Group</div>
                <pre><code class="language-csharp">mixer.AddSource(fileSource0);
mixer.AddSource(fileSource1);
mixer.AddSource(fileSource2);
mixer.AddSource(fileSource3);

var syncGroup = mixer.CreateSyncGroup("Demo", fileSource0, fileSource1, fileSource2, fileSource3);

mixer.Start();

mixer.StartSyncGroup("Demo");</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Add all four audio sources to the mixer's processing pipeline</li>
                <li>Create a synchronization group named "Demo" containing all sources</li>
                <li>Start the mixer's internal processing (begins requesting audio from sources)</li>
                <li>Start the sync group to play all sources simultaneously</li>
                <li>The sync group ensures all tracks play in perfect synchronization with drift correction</li>
                <li>Drift correction compensates for any timing differences between sources</li>
            </ul>

            <h2 id="step7-monitoring">Step 7: Real-time Monitoring and Dynamic Effects</h2>
            <p>Monitor playback progress and peak levels in real-time, with dynamic effect activation during playback.</p>

            <div class="code-block">
                <div class="code-header">Monitoring Loop</div>
                <pre><code class="language-csharp">DateTime startTime = DateTime.Now;

while (fileSource0.State == SourceState.Playing)
{
    Thread.Sleep(100);

    double position = fileSource0.Position;
    double duration = fileSource0.Duration;
    int progressPercent = (int)((position / duration) * 100);
    
    int barWidth = 40;
    int filledWidth = (int)((position / duration) * barWidth);
    string progressBar = new string('‚ñà', filledWidth) + new string('‚ñë', barWidth - filledWidth);

    string infoLine = $"Position: {TimeSpan.FromSeconds(position)} / {TimeSpan.FromSeconds(duration)} [{progressBar}] {progressPercent}%";
    string peakLine = $"| Peaks: L={mixer.LeftPeak:F2} R={mixer.RightPeak:F2}";

    Console.Write(infoLine + peakLine);

    if (position > 30 && position < 35)
    {
        _equalizer.Enabled = true;
        _compressor.Enabled = true;
    }
}</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Record the start time for tempo accuracy calculation</li>
                <li>Loop while the first source is in <code>Playing</code> state</li>
                <li>Sleep 100ms between updates to avoid excessive CPU usage</li>
                <li>Query current playback position and total duration from the source</li>
                <li>Calculate progress percentage and create a visual progress bar</li>
                <li>Display position, duration, progress bar, and peak levels (left/right channels)</li>
                <li><strong>Dynamic effect activation:</strong> Enable equalizer and compressor between 30-35 seconds</li>
                <li>This demonstrates real-time effect toggling without interrupting playback</li>
            </ul>

            <div class="code-block">
                <div class="code-header">Playback Statistics</div>
                <pre><code class="language-csharp">Console.WriteLine("Playback completed!");

TimeSpan elapsed = DateTime.Now - startTime;
double finalPosition = fileSource0.Position;

Console.WriteLine($"Real-time elapsed: {elapsed.TotalSeconds:F2} seconds");
Console.WriteLine($"Audio position reached: {finalPosition:F2} seconds");

double tempoRatio = finalPosition / elapsed.TotalSeconds;
double tempoError = (tempoRatio - 1.0) * 100.0;

Console.WriteLine($"Tempo ratio: {tempoRatio:F4} (1.0000 = perfect)");
if (Math.Abs(tempoError) < 0.5)
{
    Console.WriteLine($"Tempo accuracy: EXCELLENT ({tempoError:+0.00;-0.00}%)");
}
else if (Math.Abs(tempoError) < 2.0)
{
    Console.WriteLine($"Tempo accuracy: Good ({tempoError:+0.00;-0.00}%)");
}
else
{
    Console.WriteLine($"Tempo accuracy: POOR ({tempoError:+0.00;-0.00}%)");
}</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Calculate elapsed real-world time and final audio position</li>
                <li>Compute tempo ratio (should be 1.0 for perfect playback speed)</li>
                <li>Calculate tempo error as percentage deviation from ideal</li>
                <li>Display accuracy assessment: Excellent (&lt;0.5% error), Good (&lt;2% error), or Poor</li>
                <li>This verifies that the audio engine maintains accurate playback timing</li>
            </ul>

            <h2 id="step8-cleanup">Step 8: Cleanup and Shutdown</h2>
            <p>Properly dispose of all resources and shut down the audio engine.</p>

            <div class="code-block">
                <div class="code-header">Resource Cleanup</div>
                <pre><code class="language-csharp">Console.WriteLine("=== FINAL STATISTICS ===");
Console.WriteLine($"Total mixed frames: {mixer.TotalMixedFrames}");
Console.WriteLine($"Total underruns: {mixer.TotalUnderruns}");
Console.WriteLine($"Master volume: {mixer.MasterVolume:P0}");
Console.WriteLine($"Source state: {fileSource0.State}");
Console.WriteLine($"Final position: {fileSource0.Position:F2}s / {fileSource0.Duration:F2}s");

Console.WriteLine("=== CLEANUP ===");

mixer.Stop();
mixer.StopSyncGroup("Demo");
mixer.Dispose();

fileSource0.Dispose();
fileSource1.Dispose();
fileSource2.Dispose();
fileSource3.Dispose();

OwnaudioNet.Stop();
OwnaudioNet.Shutdown();</code></pre>
            </div>

            <p><strong>What happens here:</strong></p>
            <ul>
                <li>Display final statistics including total processed frames and underrun count</li>
                <li>Stop the mixer's processing and the sync group</li>
                <li>Dispose the mixer to release its internal resources</li>
                <li>Dispose all file sources to close file handles and free buffers</li>
                <li>Stop the audio engine (halts the real-time processing thread)</li>
                <li>Shutdown OwnaudioNET completely, releasing all native audio resources</li>
                <li><strong>Important:</strong> Always dispose resources in this order: sources ‚Üí mixer ‚Üí engine</li>
            </ul>

            <h2>Complete Code</h2>
            <p>Here's the complete example with all necessary using statements and error handling:</p>

            <div class="code-block">
                <div class="code-header">Complete Program.cs</div>
                <pre><code class="language-csharp">using Ownaudio.Core;
using OwnaudioNET.Core;
using OwnaudioNET.Effects;
using OwnaudioNET.Mixing;
using OwnaudioNET.Sources;
using System.Reflection;

namespace OwnaudioNET.Test;

public class TestProgram
{
    public static void Main(string[] args)
    {
        AudioMixer? mixer = null;
        FileSource? fileSource0 = null;
        FileSource? fileSource1 = null;
        FileSource? fileSource2 = null;
        FileSource? fileSource3 = null;

        try
        {
            AudioConfig config = new AudioConfig()
            {
                SampleRate = 48000,
                Channels = 2,
                BufferSize = 512
            };
            
            OwnaudioNet.Initialize(config);
            OwnaudioNet.Start();

            var Engine = OwnaudioNet.Engine!.UnderlyingEngine;
            mixer = new AudioMixer(Engine, bufferSizeInFrames: 512);
            mixer.MasterVolume = 0.8f;

            var _equalizer = new Equalizer30BandEffect();
            var _compressor = new CompressorEffect(CompressorPreset.Vintage);
            
            mixer.AddMasterEffect(_equalizer);
            mixer.AddMasterEffect(_compressor);
            mixer.AddMasterEffect(new DynamicAmpEffect(DynamicAmpPreset.Live));
            
            _equalizer.Enabled = false;
            _compressor.Enabled = false;

            string? exeDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            int targetSampleRate = OwnaudioNet.Engine!.Config.SampleRate;
            int targetChannels = OwnaudioNet.Engine!.Config.Channels;

            fileSource0 = new FileSource(Path.Combine(exeDirectory, "media", "drums.wav"), 8192, targetSampleRate, targetChannels);
            fileSource1 = new FileSource(Path.Combine(exeDirectory, "media", "bass.wav"), 8192, targetSampleRate, targetChannels);
            fileSource2 = new FileSource(Path.Combine(exeDirectory, "media", "other.wav"), 8192, targetSampleRate, targetChannels);
            fileSource3 = new FileSource(Path.Combine(exeDirectory, "media", "vocals.wav"), 8192, targetSampleRate, targetChannels);

            mixer.AddSource(fileSource0);
            mixer.AddSource(fileSource1);
            mixer.AddSource(fileSource2);
            mixer.AddSource(fileSource3);

            var syncGroup = mixer.CreateSyncGroup("Demo", fileSource0, fileSource1, fileSource2, fileSource3);
            mixer.Start();
            mixer.StartSyncGroup("Demo");

            DateTime startTime = DateTime.Now;

            while (fileSource0.State == SourceState.Playing)
            {
                Thread.Sleep(100);
                
                double position = fileSource0.Position;
                double duration = fileSource0.Duration;
                
                if (position > 30 && position < 35)
                {
                    _equalizer.Enabled = true;
                    _compressor.Enabled = true;
                }
            }

            mixer.Stop();
            mixer.StopSyncGroup("Demo");
            mixer.Dispose();

            fileSource0.Dispose();
            fileSource1.Dispose();
            fileSource2.Dispose();
            fileSource3.Dispose();

            OwnaudioNet.Stop();
            OwnaudioNet.Shutdown();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"ERROR: {ex.Message}");
            
            fileSource0?.Dispose();
            fileSource1?.Dispose();
            fileSource2?.Dispose();
            fileSource3?.Dispose();
            mixer?.Dispose();
            OwnaudioNet.Shutdown();
            
            Environment.Exit(1);
        }
    }
}</code></pre>
            </div>

            <div class="alert alert-success">
                <strong>Key Takeaways</strong>
                This example demonstrates professional audio application development with OwnaudioNET, including multi-track synchronization, real-time effects processing, and proper resource management.
            </div>

            <h2>Next Steps</h2>

            <div class="feature-grid">
                <div class="feature-card">
                    <h4>üìö Core API Reference</h4>
                    <p>Learn about low-level audio engine components and direct platform access.</p>
                    <a href="api-core.html" style="color: var(--primary-color);">View Core API ‚Üí</a>
                </div>
                <div class="feature-card">
                    <h4>üìö NET API Reference</h4>
                    <p>Explore high-level APIs for mixing, effects, and audio sources.</p>
                    <a href="api-net.html" style="color: var(--primary-color);">View NET API ‚Üí</a>
                </div>
                <div class="feature-card">
                    <h4>üéöÔ∏è Audio Effects</h4>
                    <p>Discover available effects like EQ, compressor, reverb, and more.</p>
                    <a href="api-net.html#effects" style="color: var(--primary-color);">View Effects ‚Üí</a>
                </div>
            </div>

            <!--<div class="alert alert-info">
                <strong>Need Help?</strong>
                Check out our <a href="https://github.com/ModernMube/OwnAudioSharp" target="_blank" style="color: var(--primary-color);">GitHub repository</a> for issues, discussions, and community support.
            </div>-->
        </main>
    </div>

    <footer class="footer">
        <div class="footer-content">
            <div class="footer-links">
                <a href="../index.html">Home</a>
                <a href="quickstart.html">Quick Start</a>
                <a href="api-core.html">Core API</a>
                <a href="api-net.html">NET API</a>
                <a href="https://github.com/ModernMube/OwnAudioSharp" target="_blank">GitHub</a>
            </div>
            <p>&copy; 2025 OwnaudioSharp. Cross-platform audio for modern .NET developer.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        const sections = document.querySelectorAll('h2[id]');
        const navLinks = document.querySelectorAll('.sidebar-nav a');

        window.addEventListener('scroll', () => {
            let current = '';
            sections.forEach(section => {
                const sectionTop = section.offsetTop;
                if (window.pageYOffset >= sectionTop - 150) {
                    current = section.getAttribute('id');
                }
            });

            navLinks.forEach(link => {
                link.classList.remove('active');
                if (link.getAttribute('href') === `#${current}`) {
                    link.classList.add('active');
                }
            });
        });

        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });
    </script>
</body>
</html>